// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: prototypes/web.proto

package prototypes // import "github.com/linkai-io/am/protocservices/prototypes"

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type ScanGroupWebDataStats struct {
	OrgID                int32            `protobuf:"varint,1,opt,name=OrgID,proto3" json:"OrgID,omitempty"`
	GroupID              int32            `protobuf:"varint,2,opt,name=GroupID,proto3" json:"GroupID,omitempty"`
	ExpiringCerts15Days  int32            `protobuf:"varint,3,opt,name=ExpiringCerts15Days,proto3" json:"ExpiringCerts15Days,omitempty"`
	ExpiringCerts30Days  int32            `protobuf:"varint,4,opt,name=ExpiringCerts30Days,proto3" json:"ExpiringCerts30Days,omitempty"`
	UniqueWebServers     int32            `protobuf:"varint,5,opt,name=UniqueWebServers,proto3" json:"UniqueWebServers,omitempty"`
	ServerTypes          map[string]int32 `protobuf:"bytes,6,rep,name=ServerTypes" json:"ServerTypes,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *ScanGroupWebDataStats) Reset()         { *m = ScanGroupWebDataStats{} }
func (m *ScanGroupWebDataStats) String() string { return proto.CompactTextString(m) }
func (*ScanGroupWebDataStats) ProtoMessage()    {}
func (*ScanGroupWebDataStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_web_169ccc4834f2aa13, []int{0}
}
func (m *ScanGroupWebDataStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScanGroupWebDataStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ScanGroupWebDataStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ScanGroupWebDataStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScanGroupWebDataStats.Merge(dst, src)
}
func (m *ScanGroupWebDataStats) XXX_Size() int {
	return m.Size()
}
func (m *ScanGroupWebDataStats) XXX_DiscardUnknown() {
	xxx_messageInfo_ScanGroupWebDataStats.DiscardUnknown(m)
}

var xxx_messageInfo_ScanGroupWebDataStats proto.InternalMessageInfo

func (m *ScanGroupWebDataStats) GetOrgID() int32 {
	if m != nil {
		return m.OrgID
	}
	return 0
}

func (m *ScanGroupWebDataStats) GetGroupID() int32 {
	if m != nil {
		return m.GroupID
	}
	return 0
}

func (m *ScanGroupWebDataStats) GetExpiringCerts15Days() int32 {
	if m != nil {
		return m.ExpiringCerts15Days
	}
	return 0
}

func (m *ScanGroupWebDataStats) GetExpiringCerts30Days() int32 {
	if m != nil {
		return m.ExpiringCerts30Days
	}
	return 0
}

func (m *ScanGroupWebDataStats) GetUniqueWebServers() int32 {
	if m != nil {
		return m.UniqueWebServers
	}
	return 0
}

func (m *ScanGroupWebDataStats) GetServerTypes() map[string]int32 {
	if m != nil {
		return m.ServerTypes
	}
	return nil
}

type URLData struct {
	ResponseID           int64    `protobuf:"varint,1,opt,name=ResponseID,proto3" json:"ResponseID,omitempty"`
	URL                  string   `protobuf:"bytes,2,opt,name=URL,proto3" json:"URL,omitempty"`
	RawBodyLink          string   `protobuf:"bytes,3,opt,name=RawBodyLink,proto3" json:"RawBodyLink,omitempty"`
	MimeType             string   `protobuf:"bytes,4,opt,name=MimeType,proto3" json:"MimeType,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *URLData) Reset()         { *m = URLData{} }
func (m *URLData) String() string { return proto.CompactTextString(m) }
func (*URLData) ProtoMessage()    {}
func (*URLData) Descriptor() ([]byte, []int) {
	return fileDescriptor_web_169ccc4834f2aa13, []int{1}
}
func (m *URLData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *URLData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_URLData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *URLData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_URLData.Merge(dst, src)
}
func (m *URLData) XXX_Size() int {
	return m.Size()
}
func (m *URLData) XXX_DiscardUnknown() {
	xxx_messageInfo_URLData.DiscardUnknown(m)
}

var xxx_messageInfo_URLData proto.InternalMessageInfo

func (m *URLData) GetResponseID() int64 {
	if m != nil {
		return m.ResponseID
	}
	return 0
}

func (m *URLData) GetURL() string {
	if m != nil {
		return m.URL
	}
	return ""
}

func (m *URLData) GetRawBodyLink() string {
	if m != nil {
		return m.RawBodyLink
	}
	return ""
}

func (m *URLData) GetMimeType() string {
	if m != nil {
		return m.MimeType
	}
	return ""
}

type URLListResponse struct {
	OrgID                int32      `protobuf:"varint,1,opt,name=OrgID,proto3" json:"OrgID,omitempty"`
	GroupID              int32      `protobuf:"varint,2,opt,name=GroupID,proto3" json:"GroupID,omitempty"`
	HostAddress          string     `protobuf:"bytes,3,opt,name=HostAddress,proto3" json:"HostAddress,omitempty"`
	IPAddress            string     `protobuf:"bytes,4,opt,name=IPAddress,proto3" json:"IPAddress,omitempty"`
	URLRequestTimestamp  int64      `protobuf:"varint,5,opt,name=URLRequestTimestamp,proto3" json:"URLRequestTimestamp,omitempty"`
	URLs                 []*URLData `protobuf:"bytes,6,rep,name=URLs" json:"URLs,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *URLListResponse) Reset()         { *m = URLListResponse{} }
func (m *URLListResponse) String() string { return proto.CompactTextString(m) }
func (*URLListResponse) ProtoMessage()    {}
func (*URLListResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_web_169ccc4834f2aa13, []int{2}
}
func (m *URLListResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *URLListResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_URLListResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *URLListResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_URLListResponse.Merge(dst, src)
}
func (m *URLListResponse) XXX_Size() int {
	return m.Size()
}
func (m *URLListResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_URLListResponse.DiscardUnknown(m)
}

var xxx_messageInfo_URLListResponse proto.InternalMessageInfo

func (m *URLListResponse) GetOrgID() int32 {
	if m != nil {
		return m.OrgID
	}
	return 0
}

func (m *URLListResponse) GetGroupID() int32 {
	if m != nil {
		return m.GroupID
	}
	return 0
}

func (m *URLListResponse) GetHostAddress() string {
	if m != nil {
		return m.HostAddress
	}
	return ""
}

func (m *URLListResponse) GetIPAddress() string {
	if m != nil {
		return m.IPAddress
	}
	return ""
}

func (m *URLListResponse) GetURLRequestTimestamp() int64 {
	if m != nil {
		return m.URLRequestTimestamp
	}
	return 0
}

func (m *URLListResponse) GetURLs() []*URLData {
	if m != nil {
		return m.URLs
	}
	return nil
}

type WebTech struct {
	Matched              string   `protobuf:"bytes,1,opt,name=Matched,proto3" json:"Matched,omitempty"`
	Version              string   `protobuf:"bytes,2,opt,name=Version,proto3" json:"Version,omitempty"`
	Location             string   `protobuf:"bytes,3,opt,name=Location,proto3" json:"Location,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WebTech) Reset()         { *m = WebTech{} }
func (m *WebTech) String() string { return proto.CompactTextString(m) }
func (*WebTech) ProtoMessage()    {}
func (*WebTech) Descriptor() ([]byte, []int) {
	return fileDescriptor_web_169ccc4834f2aa13, []int{3}
}
func (m *WebTech) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WebTech) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WebTech.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *WebTech) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WebTech.Merge(dst, src)
}
func (m *WebTech) XXX_Size() int {
	return m.Size()
}
func (m *WebTech) XXX_DiscardUnknown() {
	xxx_messageInfo_WebTech.DiscardUnknown(m)
}

var xxx_messageInfo_WebTech proto.InternalMessageInfo

func (m *WebTech) GetMatched() string {
	if m != nil {
		return m.Matched
	}
	return ""
}

func (m *WebTech) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *WebTech) GetLocation() string {
	if m != nil {
		return m.Location
	}
	return ""
}

type WebData struct {
	Address              *AddressData        `protobuf:"bytes,1,opt,name=Address" json:"Address,omitempty"`
	Responses            []*HTTPResponse     `protobuf:"bytes,2,rep,name=Responses" json:"Responses,omitempty"`
	SnapshotLink         string              `protobuf:"bytes,3,opt,name=SnapshotLink,proto3" json:"SnapshotLink,omitempty"`
	SerializedDOMHash    string              `protobuf:"bytes,4,opt,name=SerializedDOMHash,proto3" json:"SerializedDOMHash,omitempty"`
	SerializedDOMLink    string              `protobuf:"bytes,5,opt,name=SerializedDOMLink,proto3" json:"SerializedDOMLink,omitempty"`
	ResponseTimestamp    int64               `protobuf:"varint,6,opt,name=ResponseTimestamp,proto3" json:"ResponseTimestamp,omitempty"`
	URLRequestTimestamp  int64               `protobuf:"varint,7,opt,name=URLRequestTimestamp,proto3" json:"URLRequestTimestamp,omitempty"`
	URL                  string              `protobuf:"bytes,8,opt,name=URL,proto3" json:"URL,omitempty"`
	AddressHash          string              `protobuf:"bytes,9,opt,name=AddressHash,proto3" json:"AddressHash,omitempty"`
	HostAddress          string              `protobuf:"bytes,10,opt,name=HostAddress,proto3" json:"HostAddress,omitempty"`
	IPAddress            string              `protobuf:"bytes,11,opt,name=IPAddress,proto3" json:"IPAddress,omitempty"`
	Scheme               string              `protobuf:"bytes,12,opt,name=Scheme,proto3" json:"Scheme,omitempty"`
	ResponsePort         int32               `protobuf:"varint,13,opt,name=ResponsePort,proto3" json:"ResponsePort,omitempty"`
	DetectedTech         map[string]*WebTech `protobuf:"bytes,14,rep,name=DetectedTech" json:"DetectedTech,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *WebData) Reset()         { *m = WebData{} }
func (m *WebData) String() string { return proto.CompactTextString(m) }
func (*WebData) ProtoMessage()    {}
func (*WebData) Descriptor() ([]byte, []int) {
	return fileDescriptor_web_169ccc4834f2aa13, []int{4}
}
func (m *WebData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WebData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WebData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *WebData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WebData.Merge(dst, src)
}
func (m *WebData) XXX_Size() int {
	return m.Size()
}
func (m *WebData) XXX_DiscardUnknown() {
	xxx_messageInfo_WebData.DiscardUnknown(m)
}

var xxx_messageInfo_WebData proto.InternalMessageInfo

func (m *WebData) GetAddress() *AddressData {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *WebData) GetResponses() []*HTTPResponse {
	if m != nil {
		return m.Responses
	}
	return nil
}

func (m *WebData) GetSnapshotLink() string {
	if m != nil {
		return m.SnapshotLink
	}
	return ""
}

func (m *WebData) GetSerializedDOMHash() string {
	if m != nil {
		return m.SerializedDOMHash
	}
	return ""
}

func (m *WebData) GetSerializedDOMLink() string {
	if m != nil {
		return m.SerializedDOMLink
	}
	return ""
}

func (m *WebData) GetResponseTimestamp() int64 {
	if m != nil {
		return m.ResponseTimestamp
	}
	return 0
}

func (m *WebData) GetURLRequestTimestamp() int64 {
	if m != nil {
		return m.URLRequestTimestamp
	}
	return 0
}

func (m *WebData) GetURL() string {
	if m != nil {
		return m.URL
	}
	return ""
}

func (m *WebData) GetAddressHash() string {
	if m != nil {
		return m.AddressHash
	}
	return ""
}

func (m *WebData) GetHostAddress() string {
	if m != nil {
		return m.HostAddress
	}
	return ""
}

func (m *WebData) GetIPAddress() string {
	if m != nil {
		return m.IPAddress
	}
	return ""
}

func (m *WebData) GetScheme() string {
	if m != nil {
		return m.Scheme
	}
	return ""
}

func (m *WebData) GetResponsePort() int32 {
	if m != nil {
		return m.ResponsePort
	}
	return 0
}

func (m *WebData) GetDetectedTech() map[string]*WebTech {
	if m != nil {
		return m.DetectedTech
	}
	return nil
}

type WebCertificate struct {
	OrgID                             int32    `protobuf:"varint,1,opt,name=OrgID,proto3" json:"OrgID,omitempty"`
	GroupID                           int32    `protobuf:"varint,2,opt,name=GroupID,proto3" json:"GroupID,omitempty"`
	CertificateID                     int64    `protobuf:"varint,3,opt,name=CertificateID,proto3" json:"CertificateID,omitempty"`
	ResponseTimestamp                 int64    `protobuf:"varint,4,opt,name=ResponseTimestamp,proto3" json:"ResponseTimestamp,omitempty"`
	HostAddress                       string   `protobuf:"bytes,5,opt,name=HostAddress,proto3" json:"HostAddress,omitempty"`
	Port                              string   `protobuf:"bytes,6,opt,name=Port,proto3" json:"Port,omitempty"`
	Protocol                          string   `protobuf:"bytes,7,opt,name=Protocol,proto3" json:"Protocol,omitempty"`
	KeyExchange                       string   `protobuf:"bytes,8,opt,name=KeyExchange,proto3" json:"KeyExchange,omitempty"`
	KeyExchangeGroup                  string   `protobuf:"bytes,9,opt,name=KeyExchangeGroup,proto3" json:"KeyExchangeGroup,omitempty"`
	Cipher                            string   `protobuf:"bytes,10,opt,name=Cipher,proto3" json:"Cipher,omitempty"`
	Mac                               string   `protobuf:"bytes,11,opt,name=Mac,proto3" json:"Mac,omitempty"`
	CertificateValue                  int32    `protobuf:"varint,12,opt,name=CertificateValue,proto3" json:"CertificateValue,omitempty"`
	SubjectName                       string   `protobuf:"bytes,13,opt,name=SubjectName,proto3" json:"SubjectName,omitempty"`
	SanList                           []string `protobuf:"bytes,14,rep,name=SanList" json:"SanList,omitempty"`
	Issuer                            string   `protobuf:"bytes,15,opt,name=Issuer,proto3" json:"Issuer,omitempty"`
	ValidFrom                         int64    `protobuf:"varint,16,opt,name=ValidFrom,proto3" json:"ValidFrom,omitempty"`
	ValidTo                           int64    `protobuf:"varint,17,opt,name=ValidTo,proto3" json:"ValidTo,omitempty"`
	CertificateTransparencyCompliance string   `protobuf:"bytes,18,opt,name=CertificateTransparencyCompliance,proto3" json:"CertificateTransparencyCompliance,omitempty"`
	IsDeleted                         bool     `protobuf:"varint,19,opt,name=IsDeleted,proto3" json:"IsDeleted,omitempty"`
	AddressHash                       string   `protobuf:"bytes,20,opt,name=AddressHash,proto3" json:"AddressHash,omitempty"`
	IPAddress                         string   `protobuf:"bytes,21,opt,name=IPAddress,proto3" json:"IPAddress,omitempty"`
	XXX_NoUnkeyedLiteral              struct{} `json:"-"`
	XXX_unrecognized                  []byte   `json:"-"`
	XXX_sizecache                     int32    `json:"-"`
}

func (m *WebCertificate) Reset()         { *m = WebCertificate{} }
func (m *WebCertificate) String() string { return proto.CompactTextString(m) }
func (*WebCertificate) ProtoMessage()    {}
func (*WebCertificate) Descriptor() ([]byte, []int) {
	return fileDescriptor_web_169ccc4834f2aa13, []int{5}
}
func (m *WebCertificate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WebCertificate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WebCertificate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *WebCertificate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WebCertificate.Merge(dst, src)
}
func (m *WebCertificate) XXX_Size() int {
	return m.Size()
}
func (m *WebCertificate) XXX_DiscardUnknown() {
	xxx_messageInfo_WebCertificate.DiscardUnknown(m)
}

var xxx_messageInfo_WebCertificate proto.InternalMessageInfo

func (m *WebCertificate) GetOrgID() int32 {
	if m != nil {
		return m.OrgID
	}
	return 0
}

func (m *WebCertificate) GetGroupID() int32 {
	if m != nil {
		return m.GroupID
	}
	return 0
}

func (m *WebCertificate) GetCertificateID() int64 {
	if m != nil {
		return m.CertificateID
	}
	return 0
}

func (m *WebCertificate) GetResponseTimestamp() int64 {
	if m != nil {
		return m.ResponseTimestamp
	}
	return 0
}

func (m *WebCertificate) GetHostAddress() string {
	if m != nil {
		return m.HostAddress
	}
	return ""
}

func (m *WebCertificate) GetPort() string {
	if m != nil {
		return m.Port
	}
	return ""
}

func (m *WebCertificate) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

func (m *WebCertificate) GetKeyExchange() string {
	if m != nil {
		return m.KeyExchange
	}
	return ""
}

func (m *WebCertificate) GetKeyExchangeGroup() string {
	if m != nil {
		return m.KeyExchangeGroup
	}
	return ""
}

func (m *WebCertificate) GetCipher() string {
	if m != nil {
		return m.Cipher
	}
	return ""
}

func (m *WebCertificate) GetMac() string {
	if m != nil {
		return m.Mac
	}
	return ""
}

func (m *WebCertificate) GetCertificateValue() int32 {
	if m != nil {
		return m.CertificateValue
	}
	return 0
}

func (m *WebCertificate) GetSubjectName() string {
	if m != nil {
		return m.SubjectName
	}
	return ""
}

func (m *WebCertificate) GetSanList() []string {
	if m != nil {
		return m.SanList
	}
	return nil
}

func (m *WebCertificate) GetIssuer() string {
	if m != nil {
		return m.Issuer
	}
	return ""
}

func (m *WebCertificate) GetValidFrom() int64 {
	if m != nil {
		return m.ValidFrom
	}
	return 0
}

func (m *WebCertificate) GetValidTo() int64 {
	if m != nil {
		return m.ValidTo
	}
	return 0
}

func (m *WebCertificate) GetCertificateTransparencyCompliance() string {
	if m != nil {
		return m.CertificateTransparencyCompliance
	}
	return ""
}

func (m *WebCertificate) GetIsDeleted() bool {
	if m != nil {
		return m.IsDeleted
	}
	return false
}

func (m *WebCertificate) GetAddressHash() string {
	if m != nil {
		return m.AddressHash
	}
	return ""
}

func (m *WebCertificate) GetIPAddress() string {
	if m != nil {
		return m.IPAddress
	}
	return ""
}

type HTTPResponse struct {
	ResponseID           int64             `protobuf:"varint,1,opt,name=ResponseID,proto3" json:"ResponseID,omitempty"`
	OrgID                int32             `protobuf:"varint,2,opt,name=OrgID,proto3" json:"OrgID,omitempty"`
	GroupID              int32             `protobuf:"varint,3,opt,name=GroupID,proto3" json:"GroupID,omitempty"`
	Scheme               string            `protobuf:"bytes,4,opt,name=Scheme,proto3" json:"Scheme,omitempty"`
	HostAddress          string            `protobuf:"bytes,5,opt,name=HostAddress,proto3" json:"HostAddress,omitempty"`
	IPAddress            string            `protobuf:"bytes,6,opt,name=IPAddress,proto3" json:"IPAddress,omitempty"`
	AddressHash          string            `protobuf:"bytes,7,opt,name=AddressHash,proto3" json:"AddressHash,omitempty"`
	ResponsePort         string            `protobuf:"bytes,8,opt,name=ResponsePort,proto3" json:"ResponsePort,omitempty"`
	RequestedPort        string            `protobuf:"bytes,9,opt,name=RequestedPort,proto3" json:"RequestedPort,omitempty"`
	Status               int32             `protobuf:"varint,10,opt,name=Status,proto3" json:"Status,omitempty"`
	StatusText           string            `protobuf:"bytes,11,opt,name=StatusText,proto3" json:"StatusText,omitempty"`
	URL                  string            `protobuf:"bytes,12,opt,name=URL,proto3" json:"URL,omitempty"`
	Headers              map[string]string `protobuf:"bytes,13,rep,name=Headers" json:"Headers,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	MimeType             string            `protobuf:"bytes,14,opt,name=MimeType,proto3" json:"MimeType,omitempty"`
	RawBodyLink          string            `protobuf:"bytes,15,opt,name=RawBodyLink,proto3" json:"RawBodyLink,omitempty"`
	RawBodyHash          string            `protobuf:"bytes,16,opt,name=RawBodyHash,proto3" json:"RawBodyHash,omitempty"`
	ResponseTimestamp    int64             `protobuf:"varint,17,opt,name=ResponseTimestamp,proto3" json:"ResponseTimestamp,omitempty"`
	IsDocument           bool              `protobuf:"varint,18,opt,name=IsDocument,proto3" json:"IsDocument,omitempty"`
	WebCertificate       *WebCertificate   `protobuf:"bytes,19,opt,name=WebCertificate" json:"WebCertificate,omitempty"`
	IsDeleted            bool              `protobuf:"varint,20,opt,name=IsDeleted,proto3" json:"IsDeleted,omitempty"`
	URLRequestTimestamp  int64             `protobuf:"varint,21,opt,name=URLRequestTimestamp,proto3" json:"URLRequestTimestamp,omitempty"`
	LoadHostAddress      string            `protobuf:"bytes,22,opt,name=LoadHostAddress,proto3" json:"LoadHostAddress,omitempty"`
	LoadIPAddress        string            `protobuf:"bytes,23,opt,name=LoadIPAddress,proto3" json:"LoadIPAddress,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *HTTPResponse) Reset()         { *m = HTTPResponse{} }
func (m *HTTPResponse) String() string { return proto.CompactTextString(m) }
func (*HTTPResponse) ProtoMessage()    {}
func (*HTTPResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_web_169ccc4834f2aa13, []int{6}
}
func (m *HTTPResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HTTPResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HTTPResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *HTTPResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HTTPResponse.Merge(dst, src)
}
func (m *HTTPResponse) XXX_Size() int {
	return m.Size()
}
func (m *HTTPResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_HTTPResponse.DiscardUnknown(m)
}

var xxx_messageInfo_HTTPResponse proto.InternalMessageInfo

func (m *HTTPResponse) GetResponseID() int64 {
	if m != nil {
		return m.ResponseID
	}
	return 0
}

func (m *HTTPResponse) GetOrgID() int32 {
	if m != nil {
		return m.OrgID
	}
	return 0
}

func (m *HTTPResponse) GetGroupID() int32 {
	if m != nil {
		return m.GroupID
	}
	return 0
}

func (m *HTTPResponse) GetScheme() string {
	if m != nil {
		return m.Scheme
	}
	return ""
}

func (m *HTTPResponse) GetHostAddress() string {
	if m != nil {
		return m.HostAddress
	}
	return ""
}

func (m *HTTPResponse) GetIPAddress() string {
	if m != nil {
		return m.IPAddress
	}
	return ""
}

func (m *HTTPResponse) GetAddressHash() string {
	if m != nil {
		return m.AddressHash
	}
	return ""
}

func (m *HTTPResponse) GetResponsePort() string {
	if m != nil {
		return m.ResponsePort
	}
	return ""
}

func (m *HTTPResponse) GetRequestedPort() string {
	if m != nil {
		return m.RequestedPort
	}
	return ""
}

func (m *HTTPResponse) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *HTTPResponse) GetStatusText() string {
	if m != nil {
		return m.StatusText
	}
	return ""
}

func (m *HTTPResponse) GetURL() string {
	if m != nil {
		return m.URL
	}
	return ""
}

func (m *HTTPResponse) GetHeaders() map[string]string {
	if m != nil {
		return m.Headers
	}
	return nil
}

func (m *HTTPResponse) GetMimeType() string {
	if m != nil {
		return m.MimeType
	}
	return ""
}

func (m *HTTPResponse) GetRawBodyLink() string {
	if m != nil {
		return m.RawBodyLink
	}
	return ""
}

func (m *HTTPResponse) GetRawBodyHash() string {
	if m != nil {
		return m.RawBodyHash
	}
	return ""
}

func (m *HTTPResponse) GetResponseTimestamp() int64 {
	if m != nil {
		return m.ResponseTimestamp
	}
	return 0
}

func (m *HTTPResponse) GetIsDocument() bool {
	if m != nil {
		return m.IsDocument
	}
	return false
}

func (m *HTTPResponse) GetWebCertificate() *WebCertificate {
	if m != nil {
		return m.WebCertificate
	}
	return nil
}

func (m *HTTPResponse) GetIsDeleted() bool {
	if m != nil {
		return m.IsDeleted
	}
	return false
}

func (m *HTTPResponse) GetURLRequestTimestamp() int64 {
	if m != nil {
		return m.URLRequestTimestamp
	}
	return 0
}

func (m *HTTPResponse) GetLoadHostAddress() string {
	if m != nil {
		return m.LoadHostAddress
	}
	return ""
}

func (m *HTTPResponse) GetLoadIPAddress() string {
	if m != nil {
		return m.LoadIPAddress
	}
	return ""
}

type WebSnapshot struct {
	OrgID                int32    `protobuf:"varint,1,opt,name=OrgID,proto3" json:"OrgID,omitempty"`
	GroupID              int32    `protobuf:"varint,2,opt,name=GroupID,proto3" json:"GroupID,omitempty"`
	SnapshotID           int64    `protobuf:"varint,3,opt,name=SnapshotID,proto3" json:"SnapshotID,omitempty"`
	SnapshotLink         string   `protobuf:"bytes,4,opt,name=SnapshotLink,proto3" json:"SnapshotLink,omitempty"`
	SerializedDOMLink    string   `protobuf:"bytes,5,opt,name=SerializedDOMLink,proto3" json:"SerializedDOMLink,omitempty"`
	ResponseTimestamp    int64    `protobuf:"varint,6,opt,name=ResponseTimestamp,proto3" json:"ResponseTimestamp,omitempty"`
	IsDeleted            bool     `protobuf:"varint,7,opt,name=IsDeleted,proto3" json:"IsDeleted,omitempty"`
	SerializedDOMHash    string   `protobuf:"bytes,8,opt,name=SerializedDOMHash,proto3" json:"SerializedDOMHash,omitempty"`
	URL                  string   `protobuf:"bytes,9,opt,name=URL,proto3" json:"URL,omitempty"`
	AddressHash          string   `protobuf:"bytes,10,opt,name=AddressHash,proto3" json:"AddressHash,omitempty"`
	HostAddress          string   `protobuf:"bytes,11,opt,name=HostAddress,proto3" json:"HostAddress,omitempty"`
	IPAddress            string   `protobuf:"bytes,12,opt,name=IPAddress,proto3" json:"IPAddress,omitempty"`
	ResponsePort         int32    `protobuf:"varint,13,opt,name=ResponsePort,proto3" json:"ResponsePort,omitempty"`
	Scheme               string   `protobuf:"bytes,14,opt,name=Scheme,proto3" json:"Scheme,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WebSnapshot) Reset()         { *m = WebSnapshot{} }
func (m *WebSnapshot) String() string { return proto.CompactTextString(m) }
func (*WebSnapshot) ProtoMessage()    {}
func (*WebSnapshot) Descriptor() ([]byte, []int) {
	return fileDescriptor_web_169ccc4834f2aa13, []int{7}
}
func (m *WebSnapshot) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WebSnapshot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WebSnapshot.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *WebSnapshot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WebSnapshot.Merge(dst, src)
}
func (m *WebSnapshot) XXX_Size() int {
	return m.Size()
}
func (m *WebSnapshot) XXX_DiscardUnknown() {
	xxx_messageInfo_WebSnapshot.DiscardUnknown(m)
}

var xxx_messageInfo_WebSnapshot proto.InternalMessageInfo

func (m *WebSnapshot) GetOrgID() int32 {
	if m != nil {
		return m.OrgID
	}
	return 0
}

func (m *WebSnapshot) GetGroupID() int32 {
	if m != nil {
		return m.GroupID
	}
	return 0
}

func (m *WebSnapshot) GetSnapshotID() int64 {
	if m != nil {
		return m.SnapshotID
	}
	return 0
}

func (m *WebSnapshot) GetSnapshotLink() string {
	if m != nil {
		return m.SnapshotLink
	}
	return ""
}

func (m *WebSnapshot) GetSerializedDOMLink() string {
	if m != nil {
		return m.SerializedDOMLink
	}
	return ""
}

func (m *WebSnapshot) GetResponseTimestamp() int64 {
	if m != nil {
		return m.ResponseTimestamp
	}
	return 0
}

func (m *WebSnapshot) GetIsDeleted() bool {
	if m != nil {
		return m.IsDeleted
	}
	return false
}

func (m *WebSnapshot) GetSerializedDOMHash() string {
	if m != nil {
		return m.SerializedDOMHash
	}
	return ""
}

func (m *WebSnapshot) GetURL() string {
	if m != nil {
		return m.URL
	}
	return ""
}

func (m *WebSnapshot) GetAddressHash() string {
	if m != nil {
		return m.AddressHash
	}
	return ""
}

func (m *WebSnapshot) GetHostAddress() string {
	if m != nil {
		return m.HostAddress
	}
	return ""
}

func (m *WebSnapshot) GetIPAddress() string {
	if m != nil {
		return m.IPAddress
	}
	return ""
}

func (m *WebSnapshot) GetResponsePort() int32 {
	if m != nil {
		return m.ResponsePort
	}
	return 0
}

func (m *WebSnapshot) GetScheme() string {
	if m != nil {
		return m.Scheme
	}
	return ""
}

type WebResponseFilter struct {
	OrgID                int32       `protobuf:"varint,1,opt,name=OrgID,proto3" json:"OrgID,omitempty"`
	GroupID              int32       `protobuf:"varint,2,opt,name=GroupID,proto3" json:"GroupID,omitempty"`
	Start                int64       `protobuf:"varint,3,opt,name=Start,proto3" json:"Start,omitempty"`
	Limit                int32       `protobuf:"varint,4,opt,name=Limit,proto3" json:"Limit,omitempty"`
	Filters              *FilterType `protobuf:"bytes,5,opt,name=Filters" json:"Filters,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *WebResponseFilter) Reset()         { *m = WebResponseFilter{} }
func (m *WebResponseFilter) String() string { return proto.CompactTextString(m) }
func (*WebResponseFilter) ProtoMessage()    {}
func (*WebResponseFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_web_169ccc4834f2aa13, []int{8}
}
func (m *WebResponseFilter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WebResponseFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WebResponseFilter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *WebResponseFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WebResponseFilter.Merge(dst, src)
}
func (m *WebResponseFilter) XXX_Size() int {
	return m.Size()
}
func (m *WebResponseFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_WebResponseFilter.DiscardUnknown(m)
}

var xxx_messageInfo_WebResponseFilter proto.InternalMessageInfo

func (m *WebResponseFilter) GetOrgID() int32 {
	if m != nil {
		return m.OrgID
	}
	return 0
}

func (m *WebResponseFilter) GetGroupID() int32 {
	if m != nil {
		return m.GroupID
	}
	return 0
}

func (m *WebResponseFilter) GetStart() int64 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *WebResponseFilter) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *WebResponseFilter) GetFilters() *FilterType {
	if m != nil {
		return m.Filters
	}
	return nil
}

type WebCertificateFilter struct {
	OrgID                int32       `protobuf:"varint,1,opt,name=OrgID,proto3" json:"OrgID,omitempty"`
	GroupID              int32       `protobuf:"varint,2,opt,name=GroupID,proto3" json:"GroupID,omitempty"`
	Start                int64       `protobuf:"varint,3,opt,name=Start,proto3" json:"Start,omitempty"`
	Limit                int32       `protobuf:"varint,4,opt,name=Limit,proto3" json:"Limit,omitempty"`
	Filters              *FilterType `protobuf:"bytes,5,opt,name=Filters" json:"Filters,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *WebCertificateFilter) Reset()         { *m = WebCertificateFilter{} }
func (m *WebCertificateFilter) String() string { return proto.CompactTextString(m) }
func (*WebCertificateFilter) ProtoMessage()    {}
func (*WebCertificateFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_web_169ccc4834f2aa13, []int{9}
}
func (m *WebCertificateFilter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WebCertificateFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WebCertificateFilter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *WebCertificateFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WebCertificateFilter.Merge(dst, src)
}
func (m *WebCertificateFilter) XXX_Size() int {
	return m.Size()
}
func (m *WebCertificateFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_WebCertificateFilter.DiscardUnknown(m)
}

var xxx_messageInfo_WebCertificateFilter proto.InternalMessageInfo

func (m *WebCertificateFilter) GetOrgID() int32 {
	if m != nil {
		return m.OrgID
	}
	return 0
}

func (m *WebCertificateFilter) GetGroupID() int32 {
	if m != nil {
		return m.GroupID
	}
	return 0
}

func (m *WebCertificateFilter) GetStart() int64 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *WebCertificateFilter) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *WebCertificateFilter) GetFilters() *FilterType {
	if m != nil {
		return m.Filters
	}
	return nil
}

type WebSnapshotFilter struct {
	OrgID                int32       `protobuf:"varint,1,opt,name=OrgID,proto3" json:"OrgID,omitempty"`
	GroupID              int32       `protobuf:"varint,2,opt,name=GroupID,proto3" json:"GroupID,omitempty"`
	Start                int64       `protobuf:"varint,3,opt,name=Start,proto3" json:"Start,omitempty"`
	Limit                int32       `protobuf:"varint,4,opt,name=Limit,proto3" json:"Limit,omitempty"`
	Filters              *FilterType `protobuf:"bytes,5,opt,name=Filters" json:"Filters,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *WebSnapshotFilter) Reset()         { *m = WebSnapshotFilter{} }
func (m *WebSnapshotFilter) String() string { return proto.CompactTextString(m) }
func (*WebSnapshotFilter) ProtoMessage()    {}
func (*WebSnapshotFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_web_169ccc4834f2aa13, []int{10}
}
func (m *WebSnapshotFilter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WebSnapshotFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WebSnapshotFilter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *WebSnapshotFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WebSnapshotFilter.Merge(dst, src)
}
func (m *WebSnapshotFilter) XXX_Size() int {
	return m.Size()
}
func (m *WebSnapshotFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_WebSnapshotFilter.DiscardUnknown(m)
}

var xxx_messageInfo_WebSnapshotFilter proto.InternalMessageInfo

func (m *WebSnapshotFilter) GetOrgID() int32 {
	if m != nil {
		return m.OrgID
	}
	return 0
}

func (m *WebSnapshotFilter) GetGroupID() int32 {
	if m != nil {
		return m.GroupID
	}
	return 0
}

func (m *WebSnapshotFilter) GetStart() int64 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *WebSnapshotFilter) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *WebSnapshotFilter) GetFilters() *FilterType {
	if m != nil {
		return m.Filters
	}
	return nil
}

func init() {
	proto.RegisterType((*ScanGroupWebDataStats)(nil), "ScanGroupWebDataStats")
	proto.RegisterMapType((map[string]int32)(nil), "ScanGroupWebDataStats.ServerTypesEntry")
	proto.RegisterType((*URLData)(nil), "URLData")
	proto.RegisterType((*URLListResponse)(nil), "URLListResponse")
	proto.RegisterType((*WebTech)(nil), "WebTech")
	proto.RegisterType((*WebData)(nil), "WebData")
	proto.RegisterMapType((map[string]*WebTech)(nil), "WebData.DetectedTechEntry")
	proto.RegisterType((*WebCertificate)(nil), "WebCertificate")
	proto.RegisterType((*HTTPResponse)(nil), "HTTPResponse")
	proto.RegisterMapType((map[string]string)(nil), "HTTPResponse.HeadersEntry")
	proto.RegisterType((*WebSnapshot)(nil), "WebSnapshot")
	proto.RegisterType((*WebResponseFilter)(nil), "WebResponseFilter")
	proto.RegisterType((*WebCertificateFilter)(nil), "WebCertificateFilter")
	proto.RegisterType((*WebSnapshotFilter)(nil), "WebSnapshotFilter")
}
func (m *ScanGroupWebDataStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScanGroupWebDataStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OrgID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.OrgID))
	}
	if m.GroupID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.GroupID))
	}
	if m.ExpiringCerts15Days != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.ExpiringCerts15Days))
	}
	if m.ExpiringCerts30Days != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.ExpiringCerts30Days))
	}
	if m.UniqueWebServers != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.UniqueWebServers))
	}
	if len(m.ServerTypes) > 0 {
		for k, _ := range m.ServerTypes {
			dAtA[i] = 0x32
			i++
			v := m.ServerTypes[k]
			mapSize := 1 + len(k) + sovWeb(uint64(len(k))) + 1 + sovWeb(uint64(v))
			i = encodeVarintWeb(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintWeb(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x10
			i++
			i = encodeVarintWeb(dAtA, i, uint64(v))
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *URLData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *URLData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ResponseID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.ResponseID))
	}
	if len(m.URL) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintWeb(dAtA, i, uint64(len(m.URL)))
		i += copy(dAtA[i:], m.URL)
	}
	if len(m.RawBodyLink) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintWeb(dAtA, i, uint64(len(m.RawBodyLink)))
		i += copy(dAtA[i:], m.RawBodyLink)
	}
	if len(m.MimeType) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintWeb(dAtA, i, uint64(len(m.MimeType)))
		i += copy(dAtA[i:], m.MimeType)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *URLListResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *URLListResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OrgID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.OrgID))
	}
	if m.GroupID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.GroupID))
	}
	if len(m.HostAddress) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintWeb(dAtA, i, uint64(len(m.HostAddress)))
		i += copy(dAtA[i:], m.HostAddress)
	}
	if len(m.IPAddress) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintWeb(dAtA, i, uint64(len(m.IPAddress)))
		i += copy(dAtA[i:], m.IPAddress)
	}
	if m.URLRequestTimestamp != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.URLRequestTimestamp))
	}
	if len(m.URLs) > 0 {
		for _, msg := range m.URLs {
			dAtA[i] = 0x32
			i++
			i = encodeVarintWeb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *WebTech) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WebTech) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Matched) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintWeb(dAtA, i, uint64(len(m.Matched)))
		i += copy(dAtA[i:], m.Matched)
	}
	if len(m.Version) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintWeb(dAtA, i, uint64(len(m.Version)))
		i += copy(dAtA[i:], m.Version)
	}
	if len(m.Location) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintWeb(dAtA, i, uint64(len(m.Location)))
		i += copy(dAtA[i:], m.Location)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *WebData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WebData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Address != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.Address.Size()))
		n1, err := m.Address.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if len(m.Responses) > 0 {
		for _, msg := range m.Responses {
			dAtA[i] = 0x12
			i++
			i = encodeVarintWeb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.SnapshotLink) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintWeb(dAtA, i, uint64(len(m.SnapshotLink)))
		i += copy(dAtA[i:], m.SnapshotLink)
	}
	if len(m.SerializedDOMHash) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintWeb(dAtA, i, uint64(len(m.SerializedDOMHash)))
		i += copy(dAtA[i:], m.SerializedDOMHash)
	}
	if len(m.SerializedDOMLink) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintWeb(dAtA, i, uint64(len(m.SerializedDOMLink)))
		i += copy(dAtA[i:], m.SerializedDOMLink)
	}
	if m.ResponseTimestamp != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.ResponseTimestamp))
	}
	if m.URLRequestTimestamp != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.URLRequestTimestamp))
	}
	if len(m.URL) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintWeb(dAtA, i, uint64(len(m.URL)))
		i += copy(dAtA[i:], m.URL)
	}
	if len(m.AddressHash) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintWeb(dAtA, i, uint64(len(m.AddressHash)))
		i += copy(dAtA[i:], m.AddressHash)
	}
	if len(m.HostAddress) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintWeb(dAtA, i, uint64(len(m.HostAddress)))
		i += copy(dAtA[i:], m.HostAddress)
	}
	if len(m.IPAddress) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintWeb(dAtA, i, uint64(len(m.IPAddress)))
		i += copy(dAtA[i:], m.IPAddress)
	}
	if len(m.Scheme) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintWeb(dAtA, i, uint64(len(m.Scheme)))
		i += copy(dAtA[i:], m.Scheme)
	}
	if m.ResponsePort != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.ResponsePort))
	}
	if len(m.DetectedTech) > 0 {
		for k, _ := range m.DetectedTech {
			dAtA[i] = 0x72
			i++
			v := m.DetectedTech[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovWeb(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovWeb(uint64(len(k))) + msgSize
			i = encodeVarintWeb(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintWeb(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintWeb(dAtA, i, uint64(v.Size()))
				n2, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n2
			}
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *WebCertificate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WebCertificate) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OrgID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.OrgID))
	}
	if m.GroupID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.GroupID))
	}
	if m.CertificateID != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.CertificateID))
	}
	if m.ResponseTimestamp != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.ResponseTimestamp))
	}
	if len(m.HostAddress) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintWeb(dAtA, i, uint64(len(m.HostAddress)))
		i += copy(dAtA[i:], m.HostAddress)
	}
	if len(m.Port) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintWeb(dAtA, i, uint64(len(m.Port)))
		i += copy(dAtA[i:], m.Port)
	}
	if len(m.Protocol) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintWeb(dAtA, i, uint64(len(m.Protocol)))
		i += copy(dAtA[i:], m.Protocol)
	}
	if len(m.KeyExchange) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintWeb(dAtA, i, uint64(len(m.KeyExchange)))
		i += copy(dAtA[i:], m.KeyExchange)
	}
	if len(m.KeyExchangeGroup) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintWeb(dAtA, i, uint64(len(m.KeyExchangeGroup)))
		i += copy(dAtA[i:], m.KeyExchangeGroup)
	}
	if len(m.Cipher) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintWeb(dAtA, i, uint64(len(m.Cipher)))
		i += copy(dAtA[i:], m.Cipher)
	}
	if len(m.Mac) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintWeb(dAtA, i, uint64(len(m.Mac)))
		i += copy(dAtA[i:], m.Mac)
	}
	if m.CertificateValue != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.CertificateValue))
	}
	if len(m.SubjectName) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintWeb(dAtA, i, uint64(len(m.SubjectName)))
		i += copy(dAtA[i:], m.SubjectName)
	}
	if len(m.SanList) > 0 {
		for _, s := range m.SanList {
			dAtA[i] = 0x72
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Issuer) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintWeb(dAtA, i, uint64(len(m.Issuer)))
		i += copy(dAtA[i:], m.Issuer)
	}
	if m.ValidFrom != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.ValidFrom))
	}
	if m.ValidTo != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.ValidTo))
	}
	if len(m.CertificateTransparencyCompliance) > 0 {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintWeb(dAtA, i, uint64(len(m.CertificateTransparencyCompliance)))
		i += copy(dAtA[i:], m.CertificateTransparencyCompliance)
	}
	if m.IsDeleted {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		if m.IsDeleted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.AddressHash) > 0 {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintWeb(dAtA, i, uint64(len(m.AddressHash)))
		i += copy(dAtA[i:], m.AddressHash)
	}
	if len(m.IPAddress) > 0 {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintWeb(dAtA, i, uint64(len(m.IPAddress)))
		i += copy(dAtA[i:], m.IPAddress)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *HTTPResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HTTPResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ResponseID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.ResponseID))
	}
	if m.OrgID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.OrgID))
	}
	if m.GroupID != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.GroupID))
	}
	if len(m.Scheme) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintWeb(dAtA, i, uint64(len(m.Scheme)))
		i += copy(dAtA[i:], m.Scheme)
	}
	if len(m.HostAddress) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintWeb(dAtA, i, uint64(len(m.HostAddress)))
		i += copy(dAtA[i:], m.HostAddress)
	}
	if len(m.IPAddress) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintWeb(dAtA, i, uint64(len(m.IPAddress)))
		i += copy(dAtA[i:], m.IPAddress)
	}
	if len(m.AddressHash) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintWeb(dAtA, i, uint64(len(m.AddressHash)))
		i += copy(dAtA[i:], m.AddressHash)
	}
	if len(m.ResponsePort) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintWeb(dAtA, i, uint64(len(m.ResponsePort)))
		i += copy(dAtA[i:], m.ResponsePort)
	}
	if len(m.RequestedPort) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintWeb(dAtA, i, uint64(len(m.RequestedPort)))
		i += copy(dAtA[i:], m.RequestedPort)
	}
	if m.Status != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.Status))
	}
	if len(m.StatusText) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintWeb(dAtA, i, uint64(len(m.StatusText)))
		i += copy(dAtA[i:], m.StatusText)
	}
	if len(m.URL) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintWeb(dAtA, i, uint64(len(m.URL)))
		i += copy(dAtA[i:], m.URL)
	}
	if len(m.Headers) > 0 {
		for k, _ := range m.Headers {
			dAtA[i] = 0x6a
			i++
			v := m.Headers[k]
			mapSize := 1 + len(k) + sovWeb(uint64(len(k))) + 1 + len(v) + sovWeb(uint64(len(v)))
			i = encodeVarintWeb(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintWeb(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintWeb(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.MimeType) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintWeb(dAtA, i, uint64(len(m.MimeType)))
		i += copy(dAtA[i:], m.MimeType)
	}
	if len(m.RawBodyLink) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintWeb(dAtA, i, uint64(len(m.RawBodyLink)))
		i += copy(dAtA[i:], m.RawBodyLink)
	}
	if len(m.RawBodyHash) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintWeb(dAtA, i, uint64(len(m.RawBodyHash)))
		i += copy(dAtA[i:], m.RawBodyHash)
	}
	if m.ResponseTimestamp != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.ResponseTimestamp))
	}
	if m.IsDocument {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		if m.IsDocument {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.WebCertificate != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.WebCertificate.Size()))
		n3, err := m.WebCertificate.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.IsDeleted {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		if m.IsDeleted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.URLRequestTimestamp != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.URLRequestTimestamp))
	}
	if len(m.LoadHostAddress) > 0 {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintWeb(dAtA, i, uint64(len(m.LoadHostAddress)))
		i += copy(dAtA[i:], m.LoadHostAddress)
	}
	if len(m.LoadIPAddress) > 0 {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintWeb(dAtA, i, uint64(len(m.LoadIPAddress)))
		i += copy(dAtA[i:], m.LoadIPAddress)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *WebSnapshot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WebSnapshot) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OrgID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.OrgID))
	}
	if m.GroupID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.GroupID))
	}
	if m.SnapshotID != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.SnapshotID))
	}
	if len(m.SnapshotLink) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintWeb(dAtA, i, uint64(len(m.SnapshotLink)))
		i += copy(dAtA[i:], m.SnapshotLink)
	}
	if len(m.SerializedDOMLink) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintWeb(dAtA, i, uint64(len(m.SerializedDOMLink)))
		i += copy(dAtA[i:], m.SerializedDOMLink)
	}
	if m.ResponseTimestamp != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.ResponseTimestamp))
	}
	if m.IsDeleted {
		dAtA[i] = 0x38
		i++
		if m.IsDeleted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.SerializedDOMHash) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintWeb(dAtA, i, uint64(len(m.SerializedDOMHash)))
		i += copy(dAtA[i:], m.SerializedDOMHash)
	}
	if len(m.URL) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintWeb(dAtA, i, uint64(len(m.URL)))
		i += copy(dAtA[i:], m.URL)
	}
	if len(m.AddressHash) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintWeb(dAtA, i, uint64(len(m.AddressHash)))
		i += copy(dAtA[i:], m.AddressHash)
	}
	if len(m.HostAddress) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintWeb(dAtA, i, uint64(len(m.HostAddress)))
		i += copy(dAtA[i:], m.HostAddress)
	}
	if len(m.IPAddress) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintWeb(dAtA, i, uint64(len(m.IPAddress)))
		i += copy(dAtA[i:], m.IPAddress)
	}
	if m.ResponsePort != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.ResponsePort))
	}
	if len(m.Scheme) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintWeb(dAtA, i, uint64(len(m.Scheme)))
		i += copy(dAtA[i:], m.Scheme)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *WebResponseFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WebResponseFilter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OrgID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.OrgID))
	}
	if m.GroupID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.GroupID))
	}
	if m.Start != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.Start))
	}
	if m.Limit != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.Limit))
	}
	if m.Filters != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.Filters.Size()))
		n4, err := m.Filters.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *WebCertificateFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WebCertificateFilter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OrgID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.OrgID))
	}
	if m.GroupID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.GroupID))
	}
	if m.Start != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.Start))
	}
	if m.Limit != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.Limit))
	}
	if m.Filters != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.Filters.Size()))
		n5, err := m.Filters.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *WebSnapshotFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WebSnapshotFilter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OrgID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.OrgID))
	}
	if m.GroupID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.GroupID))
	}
	if m.Start != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.Start))
	}
	if m.Limit != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.Limit))
	}
	if m.Filters != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.Filters.Size()))
		n6, err := m.Filters.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintWeb(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *ScanGroupWebDataStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OrgID != 0 {
		n += 1 + sovWeb(uint64(m.OrgID))
	}
	if m.GroupID != 0 {
		n += 1 + sovWeb(uint64(m.GroupID))
	}
	if m.ExpiringCerts15Days != 0 {
		n += 1 + sovWeb(uint64(m.ExpiringCerts15Days))
	}
	if m.ExpiringCerts30Days != 0 {
		n += 1 + sovWeb(uint64(m.ExpiringCerts30Days))
	}
	if m.UniqueWebServers != 0 {
		n += 1 + sovWeb(uint64(m.UniqueWebServers))
	}
	if len(m.ServerTypes) > 0 {
		for k, v := range m.ServerTypes {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovWeb(uint64(len(k))) + 1 + sovWeb(uint64(v))
			n += mapEntrySize + 1 + sovWeb(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *URLData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ResponseID != 0 {
		n += 1 + sovWeb(uint64(m.ResponseID))
	}
	l = len(m.URL)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	l = len(m.RawBodyLink)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	l = len(m.MimeType)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *URLListResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OrgID != 0 {
		n += 1 + sovWeb(uint64(m.OrgID))
	}
	if m.GroupID != 0 {
		n += 1 + sovWeb(uint64(m.GroupID))
	}
	l = len(m.HostAddress)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	l = len(m.IPAddress)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	if m.URLRequestTimestamp != 0 {
		n += 1 + sovWeb(uint64(m.URLRequestTimestamp))
	}
	if len(m.URLs) > 0 {
		for _, e := range m.URLs {
			l = e.Size()
			n += 1 + l + sovWeb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WebTech) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Matched)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	l = len(m.Location)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WebData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Address != nil {
		l = m.Address.Size()
		n += 1 + l + sovWeb(uint64(l))
	}
	if len(m.Responses) > 0 {
		for _, e := range m.Responses {
			l = e.Size()
			n += 1 + l + sovWeb(uint64(l))
		}
	}
	l = len(m.SnapshotLink)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	l = len(m.SerializedDOMHash)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	l = len(m.SerializedDOMLink)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	if m.ResponseTimestamp != 0 {
		n += 1 + sovWeb(uint64(m.ResponseTimestamp))
	}
	if m.URLRequestTimestamp != 0 {
		n += 1 + sovWeb(uint64(m.URLRequestTimestamp))
	}
	l = len(m.URL)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	l = len(m.AddressHash)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	l = len(m.HostAddress)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	l = len(m.IPAddress)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	l = len(m.Scheme)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	if m.ResponsePort != 0 {
		n += 1 + sovWeb(uint64(m.ResponsePort))
	}
	if len(m.DetectedTech) > 0 {
		for k, v := range m.DetectedTech {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovWeb(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovWeb(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovWeb(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WebCertificate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OrgID != 0 {
		n += 1 + sovWeb(uint64(m.OrgID))
	}
	if m.GroupID != 0 {
		n += 1 + sovWeb(uint64(m.GroupID))
	}
	if m.CertificateID != 0 {
		n += 1 + sovWeb(uint64(m.CertificateID))
	}
	if m.ResponseTimestamp != 0 {
		n += 1 + sovWeb(uint64(m.ResponseTimestamp))
	}
	l = len(m.HostAddress)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	l = len(m.Port)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	l = len(m.Protocol)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	l = len(m.KeyExchange)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	l = len(m.KeyExchangeGroup)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	l = len(m.Cipher)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	l = len(m.Mac)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	if m.CertificateValue != 0 {
		n += 1 + sovWeb(uint64(m.CertificateValue))
	}
	l = len(m.SubjectName)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	if len(m.SanList) > 0 {
		for _, s := range m.SanList {
			l = len(s)
			n += 1 + l + sovWeb(uint64(l))
		}
	}
	l = len(m.Issuer)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	if m.ValidFrom != 0 {
		n += 2 + sovWeb(uint64(m.ValidFrom))
	}
	if m.ValidTo != 0 {
		n += 2 + sovWeb(uint64(m.ValidTo))
	}
	l = len(m.CertificateTransparencyCompliance)
	if l > 0 {
		n += 2 + l + sovWeb(uint64(l))
	}
	if m.IsDeleted {
		n += 3
	}
	l = len(m.AddressHash)
	if l > 0 {
		n += 2 + l + sovWeb(uint64(l))
	}
	l = len(m.IPAddress)
	if l > 0 {
		n += 2 + l + sovWeb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HTTPResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ResponseID != 0 {
		n += 1 + sovWeb(uint64(m.ResponseID))
	}
	if m.OrgID != 0 {
		n += 1 + sovWeb(uint64(m.OrgID))
	}
	if m.GroupID != 0 {
		n += 1 + sovWeb(uint64(m.GroupID))
	}
	l = len(m.Scheme)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	l = len(m.HostAddress)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	l = len(m.IPAddress)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	l = len(m.AddressHash)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	l = len(m.ResponsePort)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	l = len(m.RequestedPort)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovWeb(uint64(m.Status))
	}
	l = len(m.StatusText)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	l = len(m.URL)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	if len(m.Headers) > 0 {
		for k, v := range m.Headers {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovWeb(uint64(len(k))) + 1 + len(v) + sovWeb(uint64(len(v)))
			n += mapEntrySize + 1 + sovWeb(uint64(mapEntrySize))
		}
	}
	l = len(m.MimeType)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	l = len(m.RawBodyLink)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	l = len(m.RawBodyHash)
	if l > 0 {
		n += 2 + l + sovWeb(uint64(l))
	}
	if m.ResponseTimestamp != 0 {
		n += 2 + sovWeb(uint64(m.ResponseTimestamp))
	}
	if m.IsDocument {
		n += 3
	}
	if m.WebCertificate != nil {
		l = m.WebCertificate.Size()
		n += 2 + l + sovWeb(uint64(l))
	}
	if m.IsDeleted {
		n += 3
	}
	if m.URLRequestTimestamp != 0 {
		n += 2 + sovWeb(uint64(m.URLRequestTimestamp))
	}
	l = len(m.LoadHostAddress)
	if l > 0 {
		n += 2 + l + sovWeb(uint64(l))
	}
	l = len(m.LoadIPAddress)
	if l > 0 {
		n += 2 + l + sovWeb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WebSnapshot) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OrgID != 0 {
		n += 1 + sovWeb(uint64(m.OrgID))
	}
	if m.GroupID != 0 {
		n += 1 + sovWeb(uint64(m.GroupID))
	}
	if m.SnapshotID != 0 {
		n += 1 + sovWeb(uint64(m.SnapshotID))
	}
	l = len(m.SnapshotLink)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	l = len(m.SerializedDOMLink)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	if m.ResponseTimestamp != 0 {
		n += 1 + sovWeb(uint64(m.ResponseTimestamp))
	}
	if m.IsDeleted {
		n += 2
	}
	l = len(m.SerializedDOMHash)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	l = len(m.URL)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	l = len(m.AddressHash)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	l = len(m.HostAddress)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	l = len(m.IPAddress)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	if m.ResponsePort != 0 {
		n += 1 + sovWeb(uint64(m.ResponsePort))
	}
	l = len(m.Scheme)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WebResponseFilter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OrgID != 0 {
		n += 1 + sovWeb(uint64(m.OrgID))
	}
	if m.GroupID != 0 {
		n += 1 + sovWeb(uint64(m.GroupID))
	}
	if m.Start != 0 {
		n += 1 + sovWeb(uint64(m.Start))
	}
	if m.Limit != 0 {
		n += 1 + sovWeb(uint64(m.Limit))
	}
	if m.Filters != nil {
		l = m.Filters.Size()
		n += 1 + l + sovWeb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WebCertificateFilter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OrgID != 0 {
		n += 1 + sovWeb(uint64(m.OrgID))
	}
	if m.GroupID != 0 {
		n += 1 + sovWeb(uint64(m.GroupID))
	}
	if m.Start != 0 {
		n += 1 + sovWeb(uint64(m.Start))
	}
	if m.Limit != 0 {
		n += 1 + sovWeb(uint64(m.Limit))
	}
	if m.Filters != nil {
		l = m.Filters.Size()
		n += 1 + l + sovWeb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WebSnapshotFilter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OrgID != 0 {
		n += 1 + sovWeb(uint64(m.OrgID))
	}
	if m.GroupID != 0 {
		n += 1 + sovWeb(uint64(m.GroupID))
	}
	if m.Start != 0 {
		n += 1 + sovWeb(uint64(m.Start))
	}
	if m.Limit != 0 {
		n += 1 + sovWeb(uint64(m.Limit))
	}
	if m.Filters != nil {
		l = m.Filters.Size()
		n += 1 + l + sovWeb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovWeb(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozWeb(x uint64) (n int) {
	return sovWeb(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ScanGroupWebDataStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWeb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScanGroupWebDataStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScanGroupWebDataStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrgID", wireType)
			}
			m.OrgID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrgID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupID", wireType)
			}
			m.GroupID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiringCerts15Days", wireType)
			}
			m.ExpiringCerts15Days = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpiringCerts15Days |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiringCerts30Days", wireType)
			}
			m.ExpiringCerts30Days = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpiringCerts30Days |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UniqueWebServers", wireType)
			}
			m.UniqueWebServers = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UniqueWebServers |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerTypes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ServerTypes == nil {
				m.ServerTypes = make(map[string]int32)
			}
			var mapkey string
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowWeb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowWeb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthWeb
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowWeb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipWeb(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthWeb
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ServerTypes[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWeb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *URLData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWeb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: URLData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: URLData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseID", wireType)
			}
			m.ResponseID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResponseID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawBodyLink", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RawBodyLink = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MimeType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MimeType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWeb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *URLListResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWeb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: URLListResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: URLListResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrgID", wireType)
			}
			m.OrgID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrgID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupID", wireType)
			}
			m.GroupID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IPAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field URLRequestTimestamp", wireType)
			}
			m.URLRequestTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.URLRequestTimestamp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URLs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URLs = append(m.URLs, &URLData{})
			if err := m.URLs[len(m.URLs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWeb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WebTech) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWeb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WebTech: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WebTech: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Matched", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Matched = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Location = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWeb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WebData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWeb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WebData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WebData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Address == nil {
				m.Address = &AddressData{}
			}
			if err := m.Address.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Responses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Responses = append(m.Responses, &HTTPResponse{})
			if err := m.Responses[len(m.Responses)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnapshotLink", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SnapshotLink = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SerializedDOMHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SerializedDOMHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SerializedDOMLink", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SerializedDOMLink = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseTimestamp", wireType)
			}
			m.ResponseTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResponseTimestamp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field URLRequestTimestamp", wireType)
			}
			m.URLRequestTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.URLRequestTimestamp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddressHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AddressHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IPAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scheme", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Scheme = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponsePort", wireType)
			}
			m.ResponsePort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResponsePort |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DetectedTech", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DetectedTech == nil {
				m.DetectedTech = make(map[string]*WebTech)
			}
			var mapkey string
			var mapvalue *WebTech
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowWeb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowWeb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthWeb
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowWeb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthWeb
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthWeb
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &WebTech{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipWeb(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthWeb
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.DetectedTech[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWeb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WebCertificate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWeb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WebCertificate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WebCertificate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrgID", wireType)
			}
			m.OrgID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrgID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupID", wireType)
			}
			m.GroupID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CertificateID", wireType)
			}
			m.CertificateID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CertificateID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseTimestamp", wireType)
			}
			m.ResponseTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResponseTimestamp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Port = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyExchange", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyExchange = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyExchangeGroup", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyExchangeGroup = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cipher", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cipher = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mac", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mac = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CertificateValue", wireType)
			}
			m.CertificateValue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CertificateValue |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubjectName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubjectName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SanList", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SanList = append(m.SanList, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Issuer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Issuer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidFrom", wireType)
			}
			m.ValidFrom = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValidFrom |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidTo", wireType)
			}
			m.ValidTo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValidTo |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CertificateTransparencyCompliance", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CertificateTransparencyCompliance = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDeleted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsDeleted = bool(v != 0)
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddressHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AddressHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IPAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWeb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HTTPResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWeb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HTTPResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HTTPResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseID", wireType)
			}
			m.ResponseID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResponseID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrgID", wireType)
			}
			m.OrgID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrgID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupID", wireType)
			}
			m.GroupID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scheme", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Scheme = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IPAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddressHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AddressHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponsePort", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResponsePort = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestedPort", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestedPort = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusText", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StatusText = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Headers == nil {
				m.Headers = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowWeb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowWeb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthWeb
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowWeb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthWeb
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipWeb(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthWeb
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Headers[mapkey] = mapvalue
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MimeType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MimeType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawBodyLink", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RawBodyLink = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawBodyHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RawBodyHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseTimestamp", wireType)
			}
			m.ResponseTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResponseTimestamp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDocument", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsDocument = bool(v != 0)
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WebCertificate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WebCertificate == nil {
				m.WebCertificate = &WebCertificate{}
			}
			if err := m.WebCertificate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDeleted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsDeleted = bool(v != 0)
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field URLRequestTimestamp", wireType)
			}
			m.URLRequestTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.URLRequestTimestamp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoadHostAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LoadHostAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoadIPAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LoadIPAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWeb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WebSnapshot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWeb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WebSnapshot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WebSnapshot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrgID", wireType)
			}
			m.OrgID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrgID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupID", wireType)
			}
			m.GroupID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnapshotID", wireType)
			}
			m.SnapshotID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SnapshotID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnapshotLink", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SnapshotLink = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SerializedDOMLink", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SerializedDOMLink = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseTimestamp", wireType)
			}
			m.ResponseTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResponseTimestamp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDeleted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsDeleted = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SerializedDOMHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SerializedDOMHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddressHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AddressHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IPAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponsePort", wireType)
			}
			m.ResponsePort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResponsePort |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scheme", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Scheme = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWeb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WebResponseFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWeb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WebResponseFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WebResponseFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrgID", wireType)
			}
			m.OrgID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrgID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupID", wireType)
			}
			m.GroupID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Filters == nil {
				m.Filters = &FilterType{}
			}
			if err := m.Filters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWeb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WebCertificateFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWeb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WebCertificateFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WebCertificateFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrgID", wireType)
			}
			m.OrgID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrgID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupID", wireType)
			}
			m.GroupID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Filters == nil {
				m.Filters = &FilterType{}
			}
			if err := m.Filters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWeb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WebSnapshotFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWeb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WebSnapshotFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WebSnapshotFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrgID", wireType)
			}
			m.OrgID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrgID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupID", wireType)
			}
			m.GroupID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Filters == nil {
				m.Filters = &FilterType{}
			}
			if err := m.Filters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWeb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipWeb(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowWeb
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthWeb
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowWeb
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipWeb(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthWeb = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowWeb   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("prototypes/web.proto", fileDescriptor_web_169ccc4834f2aa13) }

var fileDescriptor_web_169ccc4834f2aa13 = []byte{
	// 1293 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x57, 0x5d, 0x6f, 0x1b, 0x45,
	0x17, 0x7e, 0x1d, 0x7f, 0xee, 0xd8, 0xf9, 0xda, 0xba, 0x7d, 0x57, 0xa6, 0xb2, 0x82, 0x55, 0x20,
	0xe2, 0x63, 0xd3, 0xa6, 0x20, 0x50, 0x2f, 0x2a, 0xd1, 0x38, 0x25, 0x16, 0x0e, 0x8d, 0xc6, 0x76,
	0x22, 0xb8, 0x1b, 0xaf, 0x4f, 0xe3, 0x21, 0xf6, 0xae, 0xbb, 0x33, 0x4e, 0x63, 0x7e, 0x08, 0x82,
	0xbf, 0xc3, 0x15, 0x97, 0x70, 0xc9, 0x1d, 0x0a, 0xe2, 0x47, 0x70, 0x87, 0xe6, 0x63, 0xe3, 0xd9,
	0x5d, 0x5b, 0x6e, 0x24, 0x2e, 0x7a, 0x37, 0xe7, 0x39, 0x67, 0xc7, 0x67, 0xce, 0x79, 0xe6, 0x99,
	0x63, 0x54, 0x9d, 0x84, 0x01, 0x0f, 0xf8, 0x6c, 0x02, 0x6c, 0xef, 0x35, 0xf4, 0x5d, 0x69, 0xd6,
	0x1c, 0x03, 0x25, 0x83, 0x41, 0x08, 0x8c, 0x69, 0xcf, 0x3b, 0x86, 0xe7, 0x25, 0x1d, 0x71, 0x08,
	0xc5, 0x5a, 0x39, 0x1b, 0xd7, 0x6b, 0xe8, 0x6e, 0xc7, 0x23, 0xfe, 0x57, 0x61, 0x30, 0x9d, 0x9c,
	0x41, 0xbf, 0x49, 0x38, 0xe9, 0x70, 0xc2, 0x99, 0x5d, 0x45, 0xf9, 0x17, 0xe1, 0x79, 0xab, 0xe9,
	0x64, 0x76, 0x32, 0xbb, 0x79, 0xac, 0x0c, 0xdb, 0x41, 0x45, 0x19, 0xda, 0x6a, 0x3a, 0x6b, 0x12,
	0x8f, 0x4c, 0xfb, 0x21, 0xba, 0x73, 0x78, 0x35, 0xa1, 0x21, 0xf5, 0xcf, 0x0f, 0x20, 0xe4, 0xec,
	0xd1, 0x67, 0x4d, 0x32, 0x63, 0x4e, 0x56, 0x46, 0x2d, 0x72, 0xa5, 0xbe, 0x78, 0xfc, 0x50, 0x7e,
	0x91, 0x5b, 0xf0, 0x85, 0x72, 0xd9, 0x1f, 0xa2, 0xad, 0x9e, 0x4f, 0x5f, 0x4d, 0xe1, 0x0c, 0xfa,
	0x1d, 0x08, 0x2f, 0x21, 0x64, 0x4e, 0x5e, 0x86, 0xa7, 0x70, 0xbb, 0x85, 0xca, 0x6a, 0xd9, 0x15,
	0x27, 0x77, 0x0a, 0x3b, 0xd9, 0xdd, 0xf2, 0xfe, 0x07, 0xee, 0xc2, 0xc3, 0xba, 0x46, 0xe4, 0xa1,
	0xcf, 0xc3, 0x19, 0x36, 0xbf, 0xad, 0x3d, 0x45, 0x5b, 0xc9, 0x00, 0x7b, 0x0b, 0x65, 0x2f, 0x60,
	0x26, 0x8b, 0x63, 0x61, 0xb1, 0x14, 0x05, 0xbb, 0x24, 0xa3, 0x29, 0xe8, 0xc2, 0x28, 0xe3, 0xc9,
	0xda, 0x17, 0x99, 0xc6, 0x0c, 0x15, 0x7b, 0xb8, 0x2d, 0x7e, 0xcd, 0xae, 0x23, 0x84, 0x81, 0x4d,
	0x02, 0x9f, 0x81, 0x2e, 0x6d, 0x16, 0x1b, 0x88, 0xd8, 0xb6, 0x87, 0xdb, 0x72, 0x0b, 0x0b, 0x8b,
	0xa5, 0xbd, 0x83, 0xca, 0x98, 0xbc, 0x7e, 0x16, 0x0c, 0x66, 0x6d, 0xea, 0x5f, 0xc8, 0x7a, 0x5a,
	0xd8, 0x84, 0xec, 0x1a, 0x2a, 0x1d, 0xd3, 0x31, 0x88, 0xe4, 0x64, 0xf1, 0x2c, 0x7c, 0x63, 0x37,
	0x7e, 0xcf, 0xa0, 0xcd, 0x1e, 0x6e, 0xb7, 0x29, 0xe3, 0xd1, 0xaf, 0xdc, 0xba, 0xb3, 0x3b, 0xa8,
	0x7c, 0x14, 0x30, 0xfe, 0xa5, 0x62, 0x55, 0x94, 0x81, 0x01, 0xd9, 0xf7, 0x91, 0xd5, 0x3a, 0x89,
	0xfc, 0x2a, 0x85, 0x39, 0x20, 0xfa, 0xdc, 0xc3, 0x6d, 0x0c, 0xaf, 0xa6, 0xc0, 0x78, 0x97, 0x8e,
	0x81, 0x71, 0x32, 0x9e, 0xc8, 0xc6, 0x65, 0xf1, 0x22, 0x97, 0x7d, 0x1f, 0xe5, 0x7a, 0xb8, 0x1d,
	0x35, 0xad, 0xe4, 0xea, 0xea, 0x61, 0x89, 0x36, 0xbe, 0x45, 0xc5, 0x33, 0xe8, 0x77, 0xc1, 0x1b,
	0x8a, 0xa4, 0x8f, 0x09, 0xf7, 0x86, 0x30, 0xd0, 0x9d, 0x88, 0x4c, 0xe1, 0x39, 0x85, 0x90, 0xd1,
	0xc0, 0xd7, 0xc5, 0x8c, 0x4c, 0x51, 0xae, 0x76, 0xe0, 0x11, 0x2e, 0x5c, 0xea, 0x2c, 0x37, 0x76,
	0xe3, 0x9f, 0x9c, 0xdc, 0x5b, 0xb6, 0xea, 0x7d, 0x54, 0x8c, 0x8e, 0x24, 0xf6, 0x2e, 0xef, 0x57,
	0x5c, 0x6d, 0xcb, 0x5c, 0x22, 0xa7, 0xfd, 0x11, 0xb2, 0xa2, 0xd2, 0x32, 0x67, 0x4d, 0x66, 0xbc,
	0xee, 0x1e, 0x75, 0xbb, 0x27, 0x11, 0x8a, 0xe7, 0x7e, 0xbb, 0x81, 0x2a, 0x1d, 0x9f, 0x4c, 0xd8,
	0x30, 0xe0, 0x46, 0x3b, 0x63, 0x98, 0xfd, 0x31, 0xda, 0xee, 0x40, 0x48, 0xc9, 0x88, 0xfe, 0x00,
	0x83, 0xe6, 0x8b, 0xe3, 0x23, 0xc2, 0x86, 0xba, 0xaa, 0x69, 0x47, 0x2a, 0x5a, 0x6e, 0x9b, 0x5f,
	0x10, 0x1d, 0xed, 0x1d, 0x25, 0x33, 0xef, 0x44, 0x41, 0x76, 0x22, 0xed, 0x58, 0xd6, 0xb9, 0xe2,
	0xf2, 0xce, 0x69, 0xfe, 0x96, 0x62, 0xfc, 0xd5, 0x95, 0x92, 0xe7, 0xb0, 0x14, 0x7b, 0x0c, 0x28,
	0xc9, 0x2f, 0xb4, 0x82, 0x5f, 0xe5, 0x24, 0xbf, 0xee, 0xa1, 0x42, 0xc7, 0x1b, 0xc2, 0x18, 0x9c,
	0x8a, 0x74, 0x69, 0x4b, 0xd4, 0x3a, 0x3a, 0xd2, 0x49, 0x10, 0x72, 0x67, 0x5d, 0xd2, 0x3a, 0x86,
	0xd9, 0x4f, 0x51, 0xa5, 0x09, 0x1c, 0x3c, 0x0e, 0x03, 0x41, 0x28, 0x67, 0x43, 0xf6, 0xaf, 0xe6,
	0x6a, 0x12, 0xb8, 0xa6, 0x53, 0x29, 0x43, 0x2c, 0xbe, 0xd6, 0x42, 0xdb, 0xa9, 0x90, 0x05, 0xda,
	0x50, 0x37, 0xb5, 0x41, 0x30, 0x5a, 0x13, 0xd8, 0x54, 0x89, 0x5f, 0xf2, 0x68, 0xe3, 0x0c, 0xfa,
	0x42, 0xef, 0xe8, 0x4b, 0xea, 0x11, 0x7e, 0xfb, 0x9b, 0xfa, 0x00, 0xad, 0x1b, 0x9f, 0xb7, 0x9a,
	0x92, 0x5e, 0x59, 0x1c, 0x07, 0x17, 0x73, 0x20, 0xb7, 0x8c, 0x03, 0x89, 0xee, 0xe4, 0xd3, 0xdd,
	0xb1, 0x51, 0x4e, 0xd6, 0xb7, 0x20, 0x5d, 0x72, 0x2d, 0x2e, 0xd9, 0x89, 0x78, 0x60, 0xbc, 0x60,
	0x24, 0xe9, 0x62, 0xe1, 0x1b, 0x5b, 0xec, 0xf8, 0x35, 0xcc, 0x0e, 0xaf, 0xbc, 0x21, 0xf1, 0xcf,
	0x41, 0x73, 0xc5, 0x84, 0x84, 0xce, 0x1b, 0xa6, 0x3c, 0x9d, 0x26, 0x4e, 0x0a, 0x17, 0xdd, 0x3f,
	0xa0, 0x93, 0x21, 0x84, 0x9a, 0x38, 0xda, 0x12, 0x4d, 0x38, 0x26, 0x9e, 0x66, 0x8b, 0x58, 0x8a,
	0x5d, 0x8d, 0x42, 0x9c, 0xca, 0x7e, 0x54, 0xd4, 0xeb, 0x91, 0xc4, 0x45, 0x8e, 0x9d, 0x69, 0xff,
	0x7b, 0xf0, 0xf8, 0x37, 0x64, 0x0c, 0x92, 0x3a, 0x16, 0x36, 0x21, 0xd1, 0x85, 0x0e, 0xf1, 0x85,
	0xb0, 0x4a, 0xd2, 0x58, 0x38, 0x32, 0x45, 0x46, 0x2d, 0xc6, 0xa6, 0x10, 0x3a, 0x9b, 0x2a, 0x23,
	0x65, 0x09, 0x16, 0x9f, 0x92, 0x11, 0x1d, 0x3c, 0x0f, 0x83, 0xb1, 0xb3, 0x25, 0xeb, 0x3d, 0x07,
	0xa4, 0x60, 0x09, 0xa3, 0x1b, 0x38, 0xdb, 0xd2, 0x17, 0x99, 0x76, 0x1b, 0xbd, 0x6b, 0xe4, 0xd7,
	0x0d, 0x89, 0xcf, 0x26, 0x24, 0x04, 0xdf, 0x9b, 0x1d, 0x04, 0xe3, 0xc9, 0x88, 0x12, 0xdf, 0x03,
	0xc7, 0x96, 0x3f, 0xb5, 0x3a, 0x50, 0xde, 0x25, 0xd6, 0x84, 0x11, 0x70, 0x18, 0x38, 0x77, 0x76,
	0x32, 0xbb, 0x25, 0x3c, 0x07, 0x92, 0xb7, 0xb5, 0x9a, 0xbe, 0xad, 0xb1, 0xbb, 0x78, 0x37, 0x71,
	0x17, 0x1b, 0x7f, 0x17, 0x50, 0xc5, 0xd4, 0xbe, 0x95, 0x0f, 0xde, 0x0d, 0xc5, 0xd7, 0x96, 0x50,
	0x3c, 0x1b, 0xa7, 0xf8, 0xfc, 0xb2, 0xe7, 0x62, 0x97, 0x7d, 0x35, 0x4d, 0x63, 0x89, 0x17, 0x92,
	0x22, 0x92, 0x38, 0x78, 0x31, 0x7d, 0xf0, 0xa4, 0x9c, 0x28, 0xde, 0xc6, 0xe5, 0xe4, 0x01, 0x5a,
	0xd7, 0x92, 0x08, 0x03, 0x19, 0xa4, 0x58, 0x1b, 0x07, 0xe5, 0x19, 0x38, 0xe1, 0x53, 0xa5, 0x75,
	0x79, 0xac, 0x2d, 0x51, 0x2b, 0xb5, 0xea, 0xc2, 0x15, 0xd7, 0xcc, 0x35, 0x90, 0x48, 0x5c, 0x2b,
	0x73, 0x71, 0xfd, 0x14, 0x15, 0x8f, 0x80, 0x0c, 0xc4, 0x1c, 0xb4, 0xae, 0x95, 0xcb, 0xac, 0xbe,
	0xab, 0x9d, 0x4a, 0xb9, 0xa2, 0xd0, 0xd8, 0xc0, 0xb0, 0x11, 0x1f, 0x18, 0x92, 0xe3, 0xc6, 0x66,
	0x7a, 0xdc, 0x98, 0x47, 0xc8, 0x4a, 0x6d, 0xc5, 0x22, 0xa2, 0x27, 0x29, 0x2d, 0x30, 0xdb, 0xcb,
	0x04, 0xa6, 0x8e, 0x50, 0x8b, 0x35, 0x03, 0x6f, 0x3a, 0x06, 0x9f, 0x4b, 0x1e, 0x97, 0xb0, 0x81,
	0xd8, 0x9f, 0x27, 0x65, 0x51, 0xb2, 0xb6, 0xbc, 0xbf, 0xe9, 0xc6, 0x61, 0x9c, 0x54, 0xcf, 0x18,
	0xd3, 0xab, 0x49, 0xa6, 0x2f, 0x79, 0xdb, 0xee, 0x2e, 0x7f, 0xdb, 0x76, 0xd1, 0x66, 0x3b, 0x20,
	0x03, 0x93, 0x66, 0xf7, 0xe4, 0xe1, 0x93, 0xb0, 0xa0, 0x81, 0x80, 0xe6, 0x74, 0xfb, 0xbf, 0xa2,
	0x41, 0x0c, 0xac, 0x3d, 0x41, 0x15, 0xb3, 0x3f, 0xab, 0x46, 0x4a, 0xcb, 0x7c, 0x2c, 0xfe, 0xc8,
	0xa2, 0xb2, 0x18, 0x76, 0xf5, 0xdc, 0x70, 0xeb, 0x97, 0x42, 0x50, 0x4d, 0x7f, 0x7b, 0xf3, 0x4c,
	0x18, 0x48, 0x6a, 0x4e, 0xc9, 0xbd, 0xc1, 0x9c, 0xf2, 0x5f, 0x4e, 0x1e, 0xb1, 0xde, 0x15, 0x93,
	0xbd, 0x5b, 0x38, 0x21, 0x95, 0x96, 0x4d, 0x48, 0xfa, 0xda, 0x58, 0x4b, 0x67, 0x12, 0xb4, 0x72,
	0x26, 0x29, 0xaf, 0x90, 0x93, 0x4a, 0x52, 0x4e, 0xde, 0x64, 0xf6, 0x98, 0x4b, 0xd9, 0x86, 0x29,
	0x65, 0x8d, 0x1f, 0x33, 0x68, 0xfb, 0x0c, 0xfa, 0x51, 0xec, 0x73, 0xf9, 0x9f, 0xed, 0xd6, 0x1d,
	0xae, 0xa2, 0x7c, 0x87, 0x93, 0x90, 0xeb, 0xe6, 0x2a, 0x43, 0xa0, 0x6d, 0x3a, 0xa6, 0x5c, 0xff,
	0xcb, 0x52, 0x86, 0xfd, 0x1e, 0x2a, 0xaa, 0x5f, 0x51, 0xc2, 0x59, 0xde, 0x2f, 0xbb, 0xca, 0x16,
	0x92, 0x80, 0x23, 0x5f, 0xe3, 0xe7, 0x0c, 0xaa, 0xc6, 0xef, 0xd8, 0xdb, 0x93, 0x9b, 0x2e, 0x5a,
	0x44, 0xd0, 0xb7, 0x26, 0xb1, 0x67, 0x07, 0xbf, 0x5e, 0xd7, 0x33, 0xbf, 0x5d, 0xd7, 0x33, 0x7f,
	0x5e, 0xd7, 0x33, 0x3f, 0xfd, 0x55, 0xff, 0xdf, 0x77, 0x8f, 0xce, 0x29, 0x1f, 0x4e, 0xfb, 0xae,
	0x17, 0x8c, 0xf7, 0x46, 0xd4, 0xbf, 0x20, 0xf4, 0x13, 0x1a, 0xec, 0x91, 0xf1, 0x9e, 0xfc, 0x4b,
	0xee, 0x31, 0x08, 0x2f, 0xa9, 0x07, 0x6c, 0x6f, 0xfe, 0xbf, 0xbd, 0x5f, 0x90, 0xeb, 0xc7, 0xff,
	0x06, 0x00, 0x00, 0xff, 0xff, 0xd5, 0x63, 0x16, 0x3c, 0xfc, 0x0f, 0x00, 0x00,
}
